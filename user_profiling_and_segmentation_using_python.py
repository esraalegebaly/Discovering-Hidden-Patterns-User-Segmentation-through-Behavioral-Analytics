# -*- coding: utf-8 -*-
"""User Profiling and Segmentation using Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U0RzIxk1fwGrWRC3li-3jYAwGnPBWkLK
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

data = pd.read_csv("user_profiles_for_ads.csv")

print(data.head())

print(data.isnull().sum())

# setting the aesthetic style and color palette
sns.set_style("whitegrid")

# custom color palette (different colors for each bar plot)
palette = sns.color_palette("Set2", n_colors=6)

# creating subplots for the demographic distributions
fig, axes = plt.subplots(2, 2, figsize=(18, 12))
fig.suptitle('Distribution of Key Demographic Variables', fontsize=20)

# 1. Age distribution
sns.countplot(
    ax=axes[0, 0], x='Age', data=data, palette=palette, hatch='/'  # hatch adds a pattern
)
axes[0, 0].set_title('Age Distribution', fontsize=15)
axes[0, 0].tick_params(axis='x', rotation=45)

# 2. Gender distribution (using a different palette)
sns.countplot(
    ax=axes[0, 1], x='Gender', data=data, palette='Dark2', edgecolor='black'
)
axes[0, 1].set_title('Gender Distribution', fontsize=15)

# 3. Education Level distribution with more styles
sns.countplot(
    ax=axes[1, 0], x='Education Level', data=data,
    palette='cool', edgecolor='gray', hatch='.'
)
axes[1, 0].set_title('Education Level Distribution', fontsize=15)
axes[1, 0].tick_params(axis='x', rotation=45)

# 4. Income Level distribution (showing bars with hatch patterns)
sns.countplot(
    ax=axes[1, 1], x='Income Level', data=data,
    palette='viridis', edgecolor='black', hatch='*'
)
axes[1, 1].set_title('Income Level Distribution', fontsize=15)
axes[1, 1].tick_params(axis='x', rotation=45)

# Adjust layout for clarity
plt.tight_layout(rect=[0, 0.03, 1, 0.95])

# Show the plots
plt.show()

# Plotting Device Usage Distribution with enhanced styling
plt.figure(figsize=(12, 6))

# Create a countplot with customizations
sns.countplot(
    x='Device Usage', data=data,
    palette='husl',   # Color palette for variety
    edgecolor='black', hatch='/'  # Hatch pattern for bars
)

# Title and label adjustments
plt.title('Device Usage Distribution', fontsize=18)
plt.xlabel('Device Type', fontsize=14)
plt.ylabel('Count', fontsize=14)

# Rotate x-tick labels if necessary
plt.xticks(rotation=45)

# Adjust layout for better presentation
plt.tight_layout()

# Display the plot
plt.show()

# Setting plot aesthetics
sns.set_style("whitegrid")

# Creating subplots for the online behavior and ad interaction metrics
fig, axes = plt.subplots(3, 2, figsize=(20, 18))
fig.suptitle('User Online Behavior and Ad Interaction Metrics', fontsize=24, fontweight='bold')

# Time spent online on weekdays
sns.histplot(
    ax=axes[0, 0], x='Time Spent Online (hrs/weekday)', data=data,
    bins=20, kde=True, color='skyblue', edgecolor='black'
)
axes[0, 0].set_title('Time Spent Online on Weekdays', fontsize=16)
axes[0, 0].set_xlabel('Hours', fontsize=14)
axes[0, 0].set_ylabel('Frequency', fontsize=14)

# Time spent online on weekends
sns.histplot(
    ax=axes[0, 1], x='Time Spent Online (hrs/weekend)', data=data,
    bins=20, kde=True, color='orange', edgecolor='black'
)
axes[0, 1].set_title('Time Spent Online on Weekends', fontsize=16)
axes[0, 1].set_xlabel('Hours', fontsize=14)

# Likes and reactions
sns.histplot(
    ax=axes[1, 0], x='Likes and Reactions', data=data,
    bins=20, kde=True, color='green', edgecolor='black'
)
axes[1, 0].set_title('Likes and Reactions', fontsize=16)

# Click-through rates (CTR)
sns.histplot(
    ax=axes[1, 1], x='Click-Through Rates (CTR)', data=data,
    bins=20, kde=True, color='red', edgecolor='black'
)
axes[1, 1].set_title('Click-Through Rates (CTR)', fontsize=16)

# Conversion rates
sns.histplot(
    ax=axes[2, 0], x='Conversion Rates', data=data,
    bins=20, kde=True, color='purple', edgecolor='black'
)
axes[2, 0].set_title('Conversion Rates', fontsize=16)

# Ad interaction time
sns.histplot(
    ax=axes[2, 1], x='Ad Interaction Time (sec)', data=data,
    bins=20, kde=True, color='brown', edgecolor='black'
)
axes[2, 1].set_title('Ad Interaction Time (sec)', fontsize=16)

# Adjusting layout to prevent overlap and ensure a neat appearance
plt.tight_layout(rect=[0, 0.03, 1, 0.95])

# Display the plots
plt.show()

from collections import Counter

# Splitting 'Top Interests' column into a list of all interests
interests_list = data['Top Interests'].str.split(', ').sum()

# Counting the frequency of each interest
interests_counter = Counter(interests_list)

# Converting the counter to a DataFrame for easier plotting
interests_df = (
    pd.DataFrame(interests_counter.items(), columns=['Interest', 'Frequency'])
    .sort_values(by='Frequency', ascending=False)
)

# Plotting the top 10 most common interests
plt.figure(figsize=(14, 8))
sns.barplot(
    x='Frequency', y='Interest',
    data=interests_df.head(10), palette='coolwarm', edgecolor='black'
)

# Enhancing plot appearance
plt.title('Top 10 User Interests', fontsize=20, fontweight='bold')
plt.xlabel('Frequency', fontsize=14)
plt.ylabel('Interest', fontsize=14)

# Adding frequency labels on bars for better readability
for index, value in enumerate(interests_df['Frequency'].head(10)):
    plt.text(value + 1, index, str(value), ha='left', va='center', fontsize=12)

# Display the plot
plt.show()

from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans

# selecting features for clustering
features = ['Age', 'Gender', 'Income Level', 'Time Spent Online (hrs/weekday)', 'Time Spent Online (hrs/weekend)', 'Likes and Reactions', 'Click-Through Rates (CTR)']

# separating the features we want to consider for clustering
X = data[features]

# defining preprocessing for numerical and categorical features
numeric_features = ['Time Spent Online (hrs/weekday)', 'Time Spent Online (hrs/weekend)', 'Likes and Reactions', 'Click-Through Rates (CTR)']
numeric_transformer = StandardScaler()

categorical_features = ['Age', 'Gender', 'Income Level']
categorical_transformer = OneHotEncoder()

# combining preprocessing steps
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_features),
        ('cat', categorical_transformer, categorical_features)
    ])

# creating a preprocessing and clustering pipeline
pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                           ('cluster', KMeans(n_clusters=5, random_state=42))])

pipeline.fit(X)
cluster_labels = pipeline.named_steps['cluster'].labels_
data['Cluster'] = cluster_labels

print(data.head())

# computing the mean values of numerical features for each cluster
cluster_means = data.groupby('Cluster')[numeric_features].mean()

for feature in categorical_features:
    mode_series = data.groupby('Cluster')[feature].agg(lambda x: x.mode()[0])
    cluster_means[feature] = mode_series

print(cluster_means)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Example data for demonstration (replace with your actual 'cluster_means' data)
cluster_means = pd.DataFrame({
    'Time Spent Online (hrs/weekday)': [2.5, 3.1, 1.2, 4.3, 1.8],
    'Time Spent Online (hrs/weekend)': [4.0, 5.2, 2.1, 3.8, 2.0],
    'Likes and Reactions': [120, 340, 80, 450, 150],
    'Click-Through Rates (CTR)': [0.12, 0.18, 0.09, 0.15, 0.10]
}, index=['Weekend Warriors', 'Engaged Professionals',
          'Low-Key Users', 'Active Explorers', 'Budget Browsers'])

# Preparing data for the radar chart
features_to_plot = ['Time Spent Online (hrs/weekday)',
                    'Time Spent Online (hrs/weekend)',
                    'Likes and Reactions',
                    'Click-Through Rates (CTR)']
labels = np.array(features_to_plot)

# Create a dataframe for the radar chart
radar_df = cluster_means[features_to_plot].reset_index()

# Normalize the data to the range [0, 1]
radar_df_normalized = radar_df.copy()
for feature in features_to_plot:
    radar_df_normalized[feature] = (radar_df[feature] - radar_df[feature].min()) / \
                                   (radar_df[feature].max() - radar_df[feature].min())

# Add a full circle to close the radar chart
radar_df_normalized = pd.concat([radar_df_normalized, radar_df_normalized.iloc[[0]]], ignore_index=True)

# Assign names to the segments
segment_names = radar_df['index'].tolist() + [radar_df['index'][0]]

# Function to create radar charts
def plot_radar(data, labels, title):
    # Set number of variables
    num_vars = len(labels)

    # Compute angle for each axis
    angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()
    angles += angles[:1]  # Complete the loop

    # Initialize the radar plot
    fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(polar=True))

    # Plot each cluster's data
    for i in range(len(data)):
        values = data.iloc[i].tolist()[1:] + data.iloc[i].tolist()[1:2]  # Wrap around values
        ax.plot(angles, values, linewidth=2, linestyle='solid', label=segment_names[i])
        ax.fill(angles, values, alpha=0.2)  # Add transparency to filled areas

    # Set the labels for each axis
    ax.set_xticks(angles[:-1])
    ax.set_xticklabels(labels, size=12)

    # Adjust radial labels and gridlines
    ax.yaxis.set_tick_params(labelsize=10)
    ax.grid(color='gray', linestyle='dashed', linewidth=0.5)

    # Title and legend
    plt.title(title, size=20, color='navy', y=1.1)
    ax.legend(loc='upper right', bbox_to_anchor=(1.3, 1.1))

    plt.show()

# Plot the radar chart
plot_radar(radar_df_normalized, labels, "User Segmentation Radar Chart")

